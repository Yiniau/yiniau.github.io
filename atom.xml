<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiniau&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yiniau.com/"/>
  <updated>2017-05-31T14:28:30.000Z</updated>
  <id>http://yiniau.com/</id>
  
  <author>
    <name>yiniau</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker笔记_2_Dockerfile</title>
    <link href="http://yiniau.com/2017/05/26/docker%E7%AC%94%E8%AE%B0-2-Dockerfile/"/>
    <id>http://yiniau.com/2017/05/26/docker笔记-2-Dockerfile/</id>
    <published>2017-05-26T05:44:26.000Z</published>
    <updated>2017-05-31T14:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>image 采用Union-FS分层储存，通过 <code>docker commit</code> 可以保存容器的储存层为一个新的镜像，也就是将运行时储存层持久化为 image 中的一层结构</p>
<p>但是直接使用 commit 会出现诸多问题，使用 <code>docker diff &lt;container name|ID|shareID&gt;</code> 可以观察到commit之前之后的变动，在一个命令被执行后会有大量无关内容被添加，特别是一些安装软件的命令。直接使用 commit 很容易造成 image 臃肿，使用 commit 生成的 image 也被称为 <strong>黑箱镜像</strong>（生成过程不透明）。</p>
<p>docker 官方最佳实践的做法为使用 <strong>Dockerfile</strong> 定制image</p>
<h4 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h4><ul>
<li>FROM 制定基础镜像</li>
<li>RUN  执行命令</li>
<li>COPY 复制文件</li>
<li>ADD  高级的复制文件指令</li>
<li>CMD  容器启动命令</li>
<li>ENTRYPOINT 入口文件</li>
<li>ENV  设置环境变量</li>
<li>ARG  构建参数</li>
<li>VOLUME 定义匿名卷（数据卷）</li>
<li>EXPOSE 暴露接口</li>
<li>WORKDIR 制定工作目录</li>
<li>USER    制定当前用户</li>
<li>HEALTHCHECK 健康检查</li>
<li>ONBUILD 为他人做嫁衣</li>
</ul>
<p>在 Dockerfile 中每出现一个 <code>RUN</code> 就会多构建一层镜像</p>
<h4 id="使用-Dockerfile-定义-container"><a href="#使用-Dockerfile-定义-container" class="headerlink" title="使用 Dockerfile 定义 container"></a>使用 Dockerfile 定义 container</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure>
<p>上面的 Dockerfile 会新建7层镜像，多出了许多没有意义的，运行时不需要的东西。</p>
<p>这些RUN命令的目的是编译安装<code>redis</code>可执行文件，只需要用1层代替即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></div></pre></td></tr></table></figure>
<p>使用 <code>&amp;&amp;</code> 将所需命令串街起来，简化为1层。<br>Dockerfile 支持使用 <code>\</code> 对命令进行换行，格式化命令代码。</p>
<p>下面是一个大体的例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use an official Python runtime as a base image</span></div><div class="line"><span class="comment"># 使用一个官方的 Python runtime 作为基础镜像</span></div><div class="line">FROM python:2.7-slim</div><div class="line"></div><div class="line"><span class="comment"># Set the working directory to /app</span></div><div class="line"><span class="comment"># 将工作目录设置到 /app</span></div><div class="line">WORKDIR /app</div><div class="line"></div><div class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></div><div class="line"><span class="comment"># 复制当前目录下的内容到容器文件系统的 /app 下</span></div><div class="line">ADD . /app</div><div class="line"></div><div class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></div><div class="line"><span class="comment"># 安装任何需要的在 requirements.txt 中说明的 packages</span></div><div class="line">RUN pip install -r requirements.txt</div><div class="line"></div><div class="line"><span class="comment"># Make port 80 available to the world outside this container</span></div><div class="line"><span class="comment"># 将 80 端口暴露给 contanier 外部</span></div><div class="line">EXPOSE 80</div><div class="line"></div><div class="line"><span class="comment"># Define environment variable</span></div><div class="line"><span class="comment"># 定义环境变量</span></div><div class="line">ENV NAME World</div><div class="line"></div><div class="line"><span class="comment"># Run app.py when the container launches</span></div><div class="line"><span class="comment"># 当 container 启动是运行 app.py</span></div><div class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</div></pre></td></tr></table></figure>
<p>这个 <code>Dockerfile</code> 文件还包含了几个我们还没有创建的文件，即 <code>app.py</code> 和 <code>requirements.txt</code>。</p>
<p>接下来就是完成这两个文件了</p>
<h4 id="应用本身"><a href="#应用本身" class="headerlink" title="应用本身"></a>应用本身</h4><p>抓取将这两个文件并将他们放在 dockerfile 所在的文件夹下。</p>
<p>这就已经完成了一个应用，十分简单。</p>
<blockquote>
<p>当前面的 <code>Dockerfile</code> 被 build 成 image 时，<code>app.py</code> 和 <code>requirements.txt</code> 会被 <code>ADD</code> 命令添加，而 <code>app.py</code> 的输出则能通过 <code>EXPOSE</code> 命令使外部能够通过 HTTP 访问。</p>
</blockquote>
<p><strong>requriements.txt</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Flask</div><div class="line">Redis</div></pre></td></tr></table></figure>
<p><strong>app.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="comment"># Connect to Redis</span></div><div class="line">redis = Redis(host=<span class="string">"redis"</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        visits = redis.incr(<span class="string">"counter"</span>)</div><div class="line">    <span class="keyword">except</span> RedisError:</div><div class="line">        visits = <span class="string">"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"</span></div><div class="line"></div><div class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;"</span></div><div class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname(), visits=visits)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</div></pre></td></tr></table></figure>
<p>现在将看到 <code>pip install -r requirements.txt</code> 会为Python安装Flask和Redis库，并且app将会打印出环境变量 <code>NAME</code>，并且输出<code>socket.gethostname()</code>的结果。<br>最终，由于 Redis 没有在运行(因为只安装了Python库，并不是Redis自身)，我们能够预计尝试使用它的时候会失败并产生错误信息。</p>
<h4 id="Build-the-App"><a href="#Build-the-App" class="headerlink" title="Build the App"></a>Build the App</h4><p>构建开始前在系统中并不需要Python或者其他任何在requirements.txt文件中求的东西，也不会将用于构建image的库安装到主机系统上。</p>
<p>运行编译命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyhello .</div></pre></td></tr></table></figure>
<p>查看images</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker images</div><div class="line"></div><div class="line">REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">friendlyhello                               latest              d5a69ab6bd43        24 hours ago        195 MB</div></pre></td></tr></table></figure>
<p>运行后会出现一个个通知，指出Python正在 <a href="http://0.0.0.0:80" target="_blank" rel="external">http://0.0.0.0:80</a> 为你的应用程序提供服务。 但是，该消息来自容器内部，并不知道你通过 <code>EXPOSE</code> 将该容器的80端口暴露并在启动命令中remapping80到4000，正确的URL为 <strong>http：// localhost：4000</strong>。 在浏览器中访问，你会看到“Hello World”文本，容器ID和Redis错误信息。</p>
<h4 id="run-应用"><a href="#run-应用" class="headerlink" title="run 应用"></a>run 应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 4000:80 friendlyhello</div></pre></td></tr></table></figure>
<p>将会在运行 friendlyhello ，并将在 Dockerfile 中使用 <code>EXPOSE</code> 暴露的 80 端口并重映射到 4000。</p>
<p>运行之后将提示信息，提示在 <code>http://0.0.0.0:80</code> 中运行服务，但这是在 container 中的地址，主机访问的正确地址为 <code>http://localhost:4000</code>。</p>
<p><strong>后台运行 | 分离模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run <span class="_">-d</span> -p 4000:80 friendlyhello</div></pre></td></tr></table></figure>
<p>运行后会得到一条巨长的 container ID,可以使用 <code>docker ps</code> 查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker ps</div><div class="line"></div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</div><div class="line">ed4cab2deb90        friendlyhello       <span class="string">"python app.py"</span>     24 hours ago        Up About a minute   0.0.0.0:4000-&gt;80/tcp   sad_curie</div></pre></td></tr></table></figure>
<p>使用 <code>docker stop ed4cab2deb90</code> 即可停止运行。</p>
<h4 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyname .  <span class="comment"># Create image using this directory's Dockerfile</span></div><div class="line">docker run -p 4000:80 friendlyname  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></div><div class="line">docker run <span class="_">-d</span> -p 4000:80 friendlyname         <span class="comment"># Same thing, but in detached mode</span></div><div class="line">docker ps                                 <span class="comment"># See a list of all running containers</span></div><div class="line">docker stop &lt;<span class="built_in">hash</span>&gt;                     <span class="comment"># Gracefully stop the specified container</span></div><div class="line">docker ps <span class="_">-a</span>           <span class="comment"># See a list of all containers, even the ones not running</span></div><div class="line">docker <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;                   <span class="comment"># Force shutdown of the specified container</span></div><div class="line">docker rm &lt;<span class="built_in">hash</span>&gt;              <span class="comment"># Remove the specified container from this machine</span></div><div class="line">docker rm $(docker ps <span class="_">-a</span> -q)           <span class="comment"># Remove all containers from this machine</span></div><div class="line">docker images <span class="_">-a</span>                               <span class="comment"># Show all images on this machine</span></div><div class="line">docker rmi &lt;imagename&gt;            <span class="comment"># Remove the specified image from this machine</span></div><div class="line">docker rmi $(docker images -q)             <span class="comment"># Remove all images from this machine</span></div><div class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></div><div class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></div><div class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></div><div class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h1&gt;&lt;p&gt;image 采用Union-FS分层储存，通过 &lt;code&gt;docker c
    
    </summary>
    
      <category term="docker" scheme="http://yiniau.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yiniau.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记_1</title>
    <link href="http://yiniau.com/2017/05/25/docker%E7%AC%94%E8%AE%B0_1/"/>
    <id>http://yiniau.com/2017/05/25/docker笔记_1/</id>
    <published>2017-05-25T10:42:23.000Z</published>
    <updated>2017-06-06T00:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h4><p><a href="https://docs.docker.com/get-started/#container-diagram" target="_blank" rel="external">官方文档</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="external">docker从入门到实践</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我是用的是mac，所以直接使用<code>brew install docker</code>就能顺利安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker -v</div><div class="line">$ Docker version 17.03.1-ce, build c6d412e</div></pre></td></tr></table></figure>
<h4 id="先决知识"><a href="#先决知识" class="headerlink" title="先决知识"></a>先决知识</h4><ul>
<li>IP Addresses and Ports        || IP地址和端口</li>
<li>Virtual Machines              || 虚拟机</li>
<li>Editing configuration files   || 编辑配置文件</li>
<li>Basic familiarity with the ideas of code dependencies and building || 基本熟悉代码依赖和构建的思想</li>
<li>Machine resource usage terms, like CPU percentages, RAM use in bytes, etc. || 机器资源使用条款，如CPU百分比，RAM使用字节数等</li>
</ul>
<h4 id="containers-and-images-lt-容器-gt-和-lt-镜像-gt"><a href="#containers-and-images-lt-容器-gt-和-lt-镜像-gt" class="headerlink" title="containers and images || &lt;容器&gt;和&lt;镜像&gt;"></a>containers and images || &lt;容器&gt;和&lt;镜像&gt;</h4><p><strong>image</strong> 镜像是一个轻量级的、独立的、可执行的 package ，包含了所有运行一个程序需要的一切，包含 code,a runtime,libraries,environment variables,and config files。</p>
<blockquote>
<p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。</p>
</blockquote>
<p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="external">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非像是一个ISO那样的打包文件，而是一个虚拟的概念。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<blockquote>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
</blockquote>
<p><strong>container</strong> 容器是<strong>一个</strong>运行时镜像的<strong>实例</strong> - what the images becomes in memory when actully executed.<br>默认情况下，它与主机环境完全隔离，只能访问主机文件和端口（如果配置为这样做）。(端口和文件的访问都需要经过配置)<br>容器运行在主机的内核上，可以说容器的实质是进程，但是与普通进程不同的是容器拥有独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="external">命名空间</a>,因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>容器与镜像一样也使用了分层储存。<br>每一个容器运行时都是以镜像为基础层，在其上创建一个为容器运行时读写准备的储存层，可以称为<strong>容器储存层</strong><br>当容消亡时容器储存层同样消失，任何保存在容器储存层中的数据都会丢失。<br>按照 <a href="">Docker 最佳实践</a>的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<h4 id="Containers-与传统虚拟机的比较"><a href="#Containers-与传统虚拟机的比较" class="headerlink" title="Containers 与传统虚拟机的比较"></a>Containers 与传统虚拟机的比较</h4><p><strong>Virtual Machine diagram</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">          |=========|</div><div class="line">          |   VM    |</div><div class="line">|---------|---------|---------|</div><div class="line">|  App A  |  App B  |  App C  |</div><div class="line">|---------|---------|---------|</div><div class="line">|Bins/Libs|Bins/Libs|Bins/Libs|</div><div class="line">|---------|---------|---------|</div><div class="line">| GuestOS | GuestOS | GuestOS |</div><div class="line">|         |=========|         |</div><div class="line">|=============================|</div><div class="line">|          Hypervisor         |</div><div class="line">|-----------------------------|</div><div class="line">|          Host   OS          |</div><div class="line">|-----------------------------|</div><div class="line">|       Infrastructure        |</div><div class="line">|-----------------------------|</div></pre></td></tr></table></figure>
<p><strong>Container diagram</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">        |=============|</div><div class="line">        |  CONTAINER  |</div><div class="line">        |_           _|</div><div class="line">|---------|---------|---------|</div><div class="line">|  App A  |  App B  |  App C  |</div><div class="line">|---------|---------|---------|</div><div class="line">|Bins/Libs|Bins/Libs|Bins/Libs|</div><div class="line">|         |=========|         |</div><div class="line">|=============================|</div><div class="line">|        Docker Engine        |</div><div class="line">|-----------------------------|</div><div class="line">|          Host  OS           |</div><div class="line">|-----------------------------|</div><div class="line">|       Infrastructure        |</div><div class="line">|-----------------------------|</div></pre></td></tr></table></figure>
<p>传统虚拟机技术会虚拟一整套硬件，并在其上运行一个完整的操作系统，之后再运行应用程序<br>而容器内的应用直接运行于宿主机的内核上，容器没有自己的内核,多个容器可以共享一个内核。<br>容器也不进行硬件模拟，因此容器要比虚拟机<strong>轻快</strong>不少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;主要参考资料&quot;&gt;&lt;a href=&quot;#主要参考资料&quot; class=&quot;headerlink&quot; title=&quot;主要参考资料&quot;&gt;&lt;/a&gt;主要参考资料&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/#containe
    
    </summary>
    
    
      <category term="docker" scheme="http://yiniau.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yiniau.com/2017/05/23/hello-world/"/>
    <id>http://yiniau.com/2017/05/23/hello-world/</id>
    <published>2017-05-23T15:56:06.000Z</published>
    <updated>2017-05-23T15:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
