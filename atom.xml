<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiniau&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yiniau.com/"/>
  <updated>2017-07-20T08:41:48.000Z</updated>
  <id>http://yiniau.com/</id>
  
  <author>
    <name>yiniau</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>centOS 7 服务器简单保护</title>
    <link href="http://yiniau.com/2017/07/20/centOS-7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E4%BF%9D%E6%8A%A4/"/>
    <id>http://yiniau.com/2017/07/20/centOS-7-服务器简单保护/</id>
    <published>2017-07-19T16:33:57.000Z</published>
    <updated>2017-07-20T08:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centOS-7-服务器简单保护"><a href="#centOS-7-服务器简单保护" class="headerlink" title="centOS 7 服务器简单保护"></a>centOS 7 服务器简单保护</h1><p>参考如下</p>
<p><a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html#sec-Start_firewalld" target="_blank" rel="external">redhat linux 计算机安全</a></p>
<p><a href="https://linux.cn/article-8076-1.html" target="_blank" rel="external">linux 中国</a></p>
<h3 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h3><p>我用的是 vultr 的vps<br>os 为 centOS 7</p>
<p>因此防火墙不能再使用 iptables 服务。可以使用firewall-cmd代替</p>
<p><strong>1 - 查看是否已经开启防火墙</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl status firewalld</div></pre></td></tr></table></figure></p>
<p><strong>1.1 - 开启防火墙</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start firewalld</div></pre></td></tr></table></figure></p>
<p><strong>2 - 配置防火墙</strong></p>
<p><strong>2.1 - 使用CLI查看防火墙设置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --state <span class="comment"># 得到 firewalld 的状态的文本显示</span></div><div class="line">firewall-cmd --get-active-zones <span class="comment"># 查看活动分区的列别，并附带一个目前分配给它们的接口列表</span></div><div class="line">firewall-cmd --get-zone-of-interface=public <span class="comment"># 找出当前分配了接口（例如 public）的区域</span></div><div class="line">sudo firewall-cmd --zone=public --list-interfaces <span class="comment"># 找出分配给一个区域（例如公共区域）的所有接口,从 NetworkManager 可以得到这个信息，并且仅显示接口而非连接。</span></div><div class="line">sudo firewall-cmd --zone=public --list-all <span class="comment"># 找出像公共区域这样的一个区域的所有设置</span></div><div class="line">sudo firewall-cmd -get-service <span class="comment"># 查看目前活动的网络区域</span></div><div class="line"><span class="comment"># 这样将列出 /usr/lib/firewalld/services/ 中的服务器名称。注意，配置文件是以服务本身命名的 service-name.xml。</span></div><div class="line"></div><div class="line">sudo firewall-cmd --get-service --permanent <span class="comment"># 查看所有在防火墙下次加载后将活跃的网络区域</span></div></pre></td></tr></table></figure>
<p><strong>2.2 - 使用CLI更改设置</strong><br>因为不是专业的运维，很多都不懂，所以就只开启流量端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo firewall-cmd --permanent --zone=public --add-port=443/tcp</div><div class="line">sudo firewall-cmd --permanent --zone=public --add-port=443/udp</div><div class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</div><div class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</div><div class="line"><span class="comment"># 目前服务器只用在翻墙，所以只开443的tcp协议和udp协议</span></div><div class="line"><span class="comment"># 将来可能会用作建站，所以就允许了http服务的流量和https的流量</span></div></pre></td></tr></table></figure></p>
<p><strong>3 - 重载防火墙</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo firewall-cmd --reload</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;centOS-7-服务器简单保护&quot;&gt;&lt;a href=&quot;#centOS-7-服务器简单保护&quot; class=&quot;headerlink&quot; title=&quot;centOS 7 服务器简单保护&quot;&gt;&lt;/a&gt;centOS 7 服务器简单保护&lt;/h1&gt;&lt;p&gt;参考如下&lt;/p&gt;
&lt;p&gt;&lt;a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用docker配置开发端环境</title>
    <link href="http://yiniau.com/2017/07/18/%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%AB%AF%E7%8E%AF%E5%A2%83/"/>
    <id>http://yiniau.com/2017/07/18/使用docker配置开发端环境/</id>
    <published>2017-07-18T14:14:10.000Z</published>
    <updated>2017-07-19T08:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用docker配置开发环境"><a href="#使用docker配置开发环境" class="headerlink" title="使用docker配置开发环境"></a>使用docker配置开发环境</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用docker配置开发环境&quot;&gt;&lt;a href=&quot;#使用docker配置开发环境&quot; class=&quot;headerlink&quot; title=&quot;使用docker配置开发环境&quot;&gt;&lt;/a&gt;使用docker配置开发环境&lt;/h1&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yiniau.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>～事件～</title>
    <link href="http://yiniau.com/2017/07/11/%EF%BD%9E%E4%BA%8B%E4%BB%B6%EF%BD%9E/"/>
    <id>http://yiniau.com/2017/07/11/～事件～/</id>
    <published>2017-07-11T12:03:14.000Z</published>
    <updated>2017-07-18T08:53:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件！事件！事件！"><a href="#事件！事件！事件！" class="headerlink" title="事件！事件！事件！"></a>事件！事件！事件！</h1><hr>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events" target="_blank" rel="external">参考链接</a></strong></p>
<blockquote>
<p>最近在重学基础，看到事件，做一个总结。<br>路线 : 事件注册 -&gt; 事件监听 -&gt; 事件处理</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事件和事件处理提供了javascript中的用于反应用户web页面打开的时间中发生的事件的核心技术，包括页面正在准备展示时发生的事件、由用户与页面交互产生的事件、由于媒体流播放或动画定时等许多其他原因引起的事件。</p>
<p>最初，浏览器会获得一个页面的所有部分来解析，处理，绘制和呈现该页面给用户，然后浏览器将保持不变，直到请求和提取新页面为止。随之变为事件驱动的、基于reflow的页面渲染，浏览器将在处理，绘制，呈现内容之间重复循环，并等待一些新的事件触发器再次启动循环。事件触发器包括完成网络上的资源的加载（例如图像已被下载并且现在可以在屏幕上绘制），完成浏览器解析资源（例如HTML页面已被处理），用户与页面的内容的交互（例如，已经点击了按钮）。Douglas Crockford在几次讲座中有效地解释了这一变化，特别是他的话题 <strong>《An Inconvenient API: The Theory of the DOM》</strong> (不方便的API:DOM理论)，其中描述了从 original flow 到事件驱动浏览器的 flow 变化。(the change in flow from the original flow to the event driven browser.)<br><img src="https://mdn.mozillademos.org/files/6641/Browser_sequence_comparitive.svg" alt="古老的原型和基于事件、flow、渲染的现代模型"><br>后一种方法将最后一步从单一流程转变为永久循环，其中绘制<code>paint</code>之后是等待和处理新事件的发生。后一种方法的创新允许页面部分呈现，即使尚未获得资源;该方法也允许javascript影响事件驱动的行为。目前，Javascript代码的所有执行环境都使用事件和事件处理。</p>
<h6 id="事件设计模式"><a href="#事件设计模式" class="headerlink" title="事件设计模式"></a>事件设计模式</h6><p>事件系统(the event system)的核心是一个简单的编程设计模式。这种模式从一类事件的协议开始：</p>
<ul>
<li>用于描述事件名称的 string</li>
<li>用于表示该事件的关键属性的数据结构的类型</li>
<li>将发射(<code>emit</code>)该事件的Javascript对象。<br>要使用该模式，需要：</li>
<li>定义一个function，其作为一个议定的数据结构的参数</li>
<li>通过使用前面的名称string与一个emit该事件的对象注册该function。</li>
</ul>
<p>这些function被称为“listener(监听函数)”或者“handler(处理函数)”，如在<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Creating_and_triggering_events" target="_blank" rel="external">自定义事件的文章</a>中所述，可以使用完全自定义的代码轻松实现此模式。</p>
<h6 id="Notable-events"><a href="#Notable-events" class="headerlink" title="Notable events"></a>Notable events</h6><p>浏览器使用<code>addEventListen(...)</code>用作事件注册函数，该方法使用一个描述事件名称的string和一个事件处理函数作为参数。浏览器将大量对象定义为事件发射器，并定义了由对象生成的各种事件类型。</p>
<p>在<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events" target="_blank" rel="external">这里</a>有一个持续维护的现代浏览器使用的标准事件的列表(目前还不完整)</p>
<p>一般来说，我们可以根据发出事件的对象来区分不同类型的事件，包括：</p>
<ul>
<li><code>window</code> 对象，列如浏览器窗口大小变化</li>
<li><code>window.screen</code> 对象，如由于设备方向的变化</li>
<li><code>document</code> 对象，包括加载，修改，用户交互和卸载页面</li>
<li>DOM（文档对象模型）树中的对象，包括用户交互或修改</li>
<li>用于网络请求的XMLHttpRequest对象，媒体对象如音视频，当媒体流播放器改变状态。</li>
</ul>
<p><strong>一些关键事件</strong><br>当页面完成渲染时，全局对象<code>window</code>会发出一个名为“load”的事件，这意味着所有资源已被下载和执行，从而运行脚本并显示图像。<br>当用户改变浏览器窗口大小的时候，<code>window</code>会发出一个名为“resize”的事件。<br>表示HTML文档的DOM对象 <code>document</code> 在文档加载完成时会发出一个名为“DOMContentLoaded”的事件。</p>
<h6 id="event-对象的层次结构"><a href="#event-对象的层次结构" class="headerlink" title="event 对象的层次结构"></a>event 对象的层次结构</h6><p>下面是一幅<br><img src="https://mdn.mozillademos.org/files/6633/Js_Event_Object_Hierarchy.svg" alt="部分图"></p>
<hr>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>对于浏览器提供的事件，上面有一个列表，这些事件可以直接使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比如说点击事件 (click)</span></div><div class="line"><span class="keyword">const</span> targetElement = <span class="built_in">document</span>.querySelect(<span class="string">'#targetELementID'</span>)</div><div class="line">targetELement.addEventListen(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'click event happened'</span>))</div></pre></td></tr></table></figure></p>
<h4 id="addEventListen-…"><a href="#addEventListen-…" class="headerlink" title="addEventListen(…)"></a>addEventListen(…)</h4><p>addEventListen 是注册事件监听函数的广义方法，在W3C文档中记以 <a href="https://www.w3.org/TR/html5/webappapis.html#event-handler-idl-attributes" target="_blank" rel="external">event handler IDL Atrribute</a>，也能处理特定的<code>on&lt;event name&gt;</code>事件。<br>优点包括：</p>
<ul>
<li>允许注册多个事件</li>
<li>当存在其他的库时，使用 <code>DHTML</code> 库或者 <code>Mozilla extensions</code> 不会出现问题。</li>
<li>它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。</li>
<li>它对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。</li>
</ul>
<p>需要注意也有几项<br><strong>当在事件分派的时候注册事件</strong> 并不会立刻触发事件，但是可能会在其他阶段触发，比如在捕获阶段注册的事件可能会在冒泡阶段被触发。<br><strong>多个相同的事件处理器</strong> 如果是在同一个 eventTarget 上注册的话重复的实例会被舍弃，所以这么做不会使得 EventListener 被调用两次，也不需要用 removeEventListener 手动清除多余的EventListener ，因为重复的都被自动抛弃了。(应该是FIFO)<br><strong>this的值</strong> 通常来说是触发元素的引用，当使用 addEventListener() 为一个元素注册事件的时候，它总是引用事件处理程序附加到的元素，而不是event.target，其与传递给句柄的 event 参数的 currentTarget 属性的值一样。但是当 <strong>直接在HTML中使用內联的方式注册事件的情况下 this 将会指向 window(严格模式下为 undefined)</strong></p>
<blockquote>
<p><strong>语法：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; target.addEventListener(type, listener[, options]);</div><div class="line">&gt; target.addEventListener(type, listener[, useCapture]);</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>type<br>  表示监听事件类型的字符串。(个人认为可以当作用于描述事件的名称字符串)<br>listener<br>  当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数(基本上所有的函数都实现了EventListener对象)<br>options<br>  一个指定有关 listener 属性的可选参数对象。可用的选项如下：</p>
<ul>
<li>capture:  <code>Boolean</code>，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。(是否捕获)</li>
<li>once:  <code>Boolean</code>，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li>
<li>passive: <code>Boolean</code>，表示 listener 永远不会调用 <code>preventDefault()</code>。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。<br>useCapture<br><code>Boolean</code>，是指在DOM树中，注册了该listener的元素，是否会先于它下方的任何事件目标，接收到该事件。沿着DOM树向上冒泡的事件不会触发被指定为use capture（也就是设为true）的listener。当一个元素嵌套了另一个元素，两个元素都对同一个事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。即在捕获模式和冒泡模式中选择一个。进一步的解释可以查看 <a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="external">事件流</a> 及 <a href="http://www.quirksmode.org/js/events_order.html#link4" target="_blank" rel="external">JavaScript Event order</a> 文档。 如果没有指定， useCapture 默认为 false 。</li>
</ul>
</blockquote>
<h4 id="注册on-event处理程序"><a href="#注册on-event处理程序" class="headerlink" title="注册on-event处理程序"></a>注册on-event处理程序</h4><p>直接在HTML的on-event属性中写事件处理函数在W3C文档中被称为 <a href="https://www.w3.org/TR/html5/webappapis.html#event-handler-content-attributes" target="_blank" rel="external">event handler content attribute</a></p>
<p>我们可以以不同的方式为给定对象指定特定事件（例如单击）的on &lt;…&gt;事件处理程序：</p>
<ul>
<li>在元素上使用{eventtype}命名的HTML属性，例如： <code>&lt;button onclick =“return handleClick（event）;”&gt;</code></li>
<li>或者通过从JavaScript设置相应的属性，例如： <code>document.getElementById(&quot;mybutton&quot;).onclick = function(event){...}</code>。</li>
</ul>
<p>请注意，每个对象对于给定的事件只能有一个事件处理程序（尽管该处理程序可以调用多个子处理程序）。<br>这就是为什么<code>addEventListener()</code>通常是更好的来获取事件通知的方式，特别是当期望相互独立地应用各种事件处理程序时，这即使是对于相同的事件 and/or 同一个元素也是如此。</p>
<p>还要注意，on-event handlers 是自动调用的，而不随程序员的意志（尽管可以 mybutton.onclick(myevent);），因为它们可以作为一个可以分配一个真正的处理函数的占位符。</p>
<p>对于 <strong>非元素对象</strong> ，我们也可以使用生成事件的许多非元素对象（包括窗口，文档，XMLHttpRequest等）的属性来设置事件处理程序，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>由于历史原因，<code>&lt;body&gt;</code>和<code>&lt;frameset&gt;</code>元素上的某些属性/属性实际上在其父窗口对象上设置了事件处理程序。 （HTML规范名称为：onblur，onerror，onfocus，onload，onscroll。）</p>
<p>当事件处理程序被指定为HTML属性时，指定的代码将被包装到具有以下参数的函数中：</p>
<ul>
<li>event == 对于所有事件处理程序，除了 onerror。</li>
<li>event, source, lineno, colno, onerror 函数的 error。请注意，事件参数实际上包含错误消息作为字符串。</li>
</ul>
<p>对于this的指向，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#In_an_in%E2%80%93line_event_handler" target="_blank" rel="external">这篇文章</a>有很详细的介绍</p>
<h2 id="来自处理程序的返回值确定事件是否被取消。返回值的具体处理取决于事件的种类，详细信息请参见HTML规范中的“事件处理程序处理算法”。"><a href="#来自处理程序的返回值确定事件是否被取消。返回值的具体处理取决于事件的种类，详细信息请参见HTML规范中的“事件处理程序处理算法”。" class="headerlink" title="来自处理程序的返回值确定事件是否被取消。返回值的具体处理取决于事件的种类，详细信息请参见HTML规范中的“事件处理程序处理算法”。"></a>来自处理程序的返回值确定事件是否被取消。返回值的具体处理取决于事件的种类，详细信息请参见HTML规范中的<a href="https://html.spec.whatwg.org/multipage/webappapis.html#the-event-handler-processing-algorithm" target="_blank" rel="external">“事件处理程序处理算法”</a>。</h2><h3 id="Mutation-event"><a href="#Mutation-event" class="headerlink" title="Mutation event"></a>Mutation event</h3><p>突变事件用于监测DOM元素是否发生改变<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="external">参考这里</a></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>MutationObObserver()</code><br>参数</p>
<ul>
<li><code>callback</code><br>该回调函数会在指定的DOM节点(目标节点)发生变化时被调用.在调用时,观察者对象会传给该函数两个参数,第一个参数是个包含了若干个MutationRecord对象的数组,第二个参数则是这个观察者对象本身.</li>
</ul>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> observe( Node target, optional MutationObserverInit options );</div><div class="line"><span class="keyword">void</span> disconnect();</div><div class="line"><span class="built_in">Array</span> takeRecords();</div></pre></td></tr></table></figure>
<p><strong>observe()</strong><br>给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> observe(</div><div class="line">  Node target,</div><div class="line">  optional MutationObserverInit options</div><div class="line">);</div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>target<br>观察该节点是否会发生DOM变化.</li>
<li>options<br>一个MutationObserverInit对象,指定要观察的DOM变化类型.</li>
</ul>
<blockquote>
<p>注：向一个元素添加 observer 和 addEventListener 类似，注册多次不会有任何影响。即是说，如果你注册了两次，回调函数不会被调用两次，你也不必执行两次 disconnect() 以停止观察。换句话说，一旦某个元素被注册观察后，使用相同的 observer 实例再次注册不会发生任何变化。当然，如果回调对象不同，那么他会向这个元素添加另一个观察者。</p>
</blockquote>
<p><strong>disconnect()</strong><br>让该观察者对象停止观察指定目标的DOM变化.直到再次调用其<code>observe()</code>方法,该观察者对象包含的回调函数都不会再被调用.</p>
<p><strong>takeRecords()</strong><br>清空观察者对象的记录队列,并返回里面的内容.</p>
<p>返回值</p>
<ul>
<li>返回一个包含了MutationRecords对象的数组.</li>
</ul>
<h4 id="MutationObserverInit"><a href="#MutationObserverInit" class="headerlink" title="MutationObserverInit"></a>MutationObserverInit</h4><p>MutationObserverInit是一个用来配置观察者对象行为的对象,该对象可以拥有下面这些属性:</p>
<ul>
<li><p>childList<br>如果需要观察目标节点的子节点(新增了某个子节点,或者移除了某个子节点),则设置为true.</p>
</li>
<li><p>attributes<br>如果需要观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化),则设置为true.</p>
</li>
<li><p>characterData<br>如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化,则设置为true.</p>
</li>
<li><p>subtree<br>除了目标节点,如果还需要观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化),则设置为true.</p>
</li>
<li><p>attributeOldValue<br>在attributes属性已经设为true的前提下,如果需要将发生变化的属性节点之前的属性值记录下来(记录到下面MutationRecord对象的oldValue属性中),则设置为true.</p>
</li>
<li><p>characterDataOldValue<br>在characterData属性已经设为true的前提下,如果需要将发生变化的characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中),则设置为true.</p>
</li>
<li><p>attributeFilter<br>一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略.</p>
</li>
</ul>
<h4 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h4><p>MutationRecord对象会作为第一个参数传递给观察者对象包含的回调函数,该对象有下面这些属性:</p>
<ul>
<li>type    String    如果是属性发生变化,则返回attributes.如果是一个CharacterData节点发生变化,则返回characterData,如果是目标节点的某个子节点发生了变化,则返回childList.</li>
<li>target    Node    返回此次变化影响到的节点,具体返回那种节点类型是根据type值的不同而不同的. 如果type为attributes,则返回发生变化的属性节点所在的元素节点,如果type值为characterData,则返回发生变化的这个characterData节点.如果type为childList,则返回发生变化的子节点的父节点.</li>
<li>addedNodes    NodeList    返回被添加的节点,或者为null.</li>
<li>removedNodes    NodeList    返回被删除的节点,或者为null.</li>
<li>previousSibling    Node    返回被添加或被删除的节点的前一个兄弟节点,或者为null.</li>
<li>nextSibling    Node    返回被添加或被删除的节点的后一个兄弟节点,或者为null.</li>
<li>attributeName    String    返回变更属性的本地名称,或者为null.</li>
<li>attributeNamespace    String    返回变更属性的命名空间,或者为null.</li>
<li>oldValue    String<br>根据type值的不同,返回的值也会不同.如果type为 attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null.</li>
</ul>
<h3 id="触发和创建事件"><a href="#触发和创建事件" class="headerlink" title="触发和创建事件"></a>触发和创建事件</h3><p>我们可以自己创建和分派DOM事件。这些事件通常称为合成事件，而不是浏览器本身触发的事件。</p>
<h4 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h4><p>Events 可以使用 Event构造函数 创建如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Listen for the event.</span></div><div class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Dispatch the event.</span></div><div class="line">elem.dispatchEvent(event);</div></pre></td></tr></table></figure>
<p>绝大多数现代浏览器中都会支持这个构造函数（Internet Explorer 例外）。 要了解更为复杂的方法，可参考下面的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events#The_old-fashioned_way" target="_blank" rel="external">过时的方法</a>  一节。</p>
<h5 id="添加自定义数据-–-CustomEvent"><a href="#添加自定义数据-–-CustomEvent" class="headerlink" title="添加自定义数据 – CustomEvent()"></a>添加自定义数据 – CustomEvent()</h5><p>要向事件对象添加更多数据，可以使用CustomEvent接口，并且detail属性可用于传递自定义数据。<br>例如，event 可以创建如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="string">'detail'</span>: elem.dataset.time &#125;);</div></pre></td></tr></table></figure>
<p>下面的代码允许你在事件监听器中访问更多的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  log(<span class="string">'The time is: '</span> + e.detail);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="触发内置事件"><a href="#触发内置事件" class="headerlink" title="触发内置事件"></a>触发内置事件</h4><p>下面的例子演示了一个在复选框上点击（click）的模拟（就是说在程序里生成一个click事件），这个模拟点击使用了DOM方法. 参见<a href="http://developer.mozilla.org/samples/domref/dispatchEvent.html" target="_blank" rel="external">这个动态示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">simulateClick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">'click'</span>, &#123;</div><div class="line">    <span class="string">'view'</span>: <span class="built_in">window</span>,</div><div class="line">    <span class="string">'bubbles'</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">'cancelable'</span>: <span class="literal">true</span></div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">'checkbox'</span>);</div><div class="line">  <span class="keyword">var</span> cancelled = !cb.dispatchEvent(event);</div><div class="line">  <span class="keyword">if</span> (cancelled) &#123;</div><div class="line">    <span class="comment">// A handler called preventDefault.</span></div><div class="line">    alert(<span class="string">"cancelled"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// None of the handlers called preventDefault.</span></div><div class="line">    alert(<span class="string">"not cancelled"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="取消事件和阻止传播"><a href="#取消事件和阻止传播" class="headerlink" title="取消事件和阻止传播"></a>取消事件和阻止传播</h3><p>某些事件被指定为可取消。 对于这些事件，DOM实现通常具有与事件相关联的默认操作。 列如Web浏览器中的超链接。 当用户点击超链接时，默认动作通常是激活该超链接。 在处理这些事件之前，实现必须检查注册的事件监听器以接收事件并将事件分派给这些监听器。 这些 <code>EventListener</code> 然后可以选择取消实现的默认动作，或允许默认动作继续。 在浏览器中的超链接的情况下，取消操作将导致不激活超链接。</p>
<p>通过调用 <code>Event</code> 的 <code>preventDefault</code>  方法来完成取消。如果有一个或多个  <code>EventListener</code> 在事件的任何阶段调用了 <code>preventDefault</code> ，那么默认动作将会取消。</p>
<p><strong>Event.preventDefault()</strong></p>
<p>被包含在Event事件对象中，可以在event handler函数中使用，用于阻止事件的默认操作。</p>
<p>下面的例子显示了用preventDefault()阻止checkbox的开关。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>preventDefault example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Please click on the checkbox control.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"id-checkbox"</span>&gt;</span>Checkbox<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"id-checkbox"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">document</span>.querySelector(<span class="string">"#id-checkbox"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">            alert(<span class="string">"preventDefault will stop you from checking this checkbox!"</span>)</div><div class="line">            event.preventDefault();</div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h4><p>对冒泡的事件（存在非冒泡的事件），事件被调度到其目标 <code>EventTarget</code> ，并且发现的任何事件监听器都被触发。然后，冒泡事件将触发任何追加 <code>EventTarget</code> 的父链的附加事件侦听器，检查在每个连续的 <code>EventTarget</code> 上注册的任何事件侦听器。这种向上传播将继续并且包括 <code>document</code> 。注册为捕获者的EventListeners在此阶段不会被触发。 <code>EventTargets</code> 链从事件目标到树的顶部在事件的初始调度之前确定。如果在事件处理过程中发生树的修改，则事件流将基于树的初始状态进行。</p>
<p>与事件捕获相同，一般用于设置默认事件或者全局捕获事件，要关闭冒泡可以使用 <code>event.stopPropagation()</code> 这样可以阻止事件在冒泡阶段的所有传播。对于完整的跨浏览器体验可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!e) <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</div><div class="line">	e.cancelBubble = <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span> (e.stopPropagation) e.stopPropagation();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如同 <code>event.preventDefault()</code>。</p>
<h3 id="事件循环模型-Event-loop"><a href="#事件循环模型-Event-loop" class="headerlink" title="事件循环模型 Event-loop"></a>事件循环模型 Event-loop</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">原文链接</a></p>
<p>JavaScript 的并发模型基于 “事件循环”。这个模型与像 C 或者 Java 这种其它语言中的模型着实不同。</p>
<p>####### 运行时概念</p>
<p><strong>栈</strong></p>
<p>函数调用会形成一个栈帧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">return</span> a + b + <span class="number">11</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> foo(x * y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bar(<span class="number">7</span>));</div></pre></td></tr></table></figure>
<p>当调用 <code>bar</code> 时，创建了第一个帧 ，帧中包含了 <code>bar</code> 的参数和局部变量。当 <code>bar</code> 调用 <code>foo</code> 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 <code>foo</code> 的参数和局部变量。当 <code>foo</code> 返回时，最上层的帧就被弹出栈（剩下 <code>bar</code> 函数的调用帧 ）。当 <code>bar</code> 返回的时候，栈就空了。</p>
<p><strong>堆</strong></p>
<p>对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域。</p>
<p><strong>队列</strong></p>
<p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈为空时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）。当栈再次为空的时候，也就意味着消息处理结束。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>之所以称为 事件循环，是因为它经常被用于类似如下的方式来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</div><div class="line">  queue.processNextMessage();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前没有任何消息，queue.waitForMessage 会同步等待消息到来。</p>
<p><strong>“执行至完成”</strong></p>
<p>每一个消息执行完成后，其它消息才会被执行。当你分析你的程序时，这点提供了一些优秀的特性，包括当一个函数运行时，它不能被取代且会在其它代码运行前先完成（而且能够修改这个函数控制的数据）。这点与C语言不同。例如，C语言中当一个程序在一个线程中运行时，它可以在任何点停止且可以在其它线程中运行其它代码。</p>
<p>这个模型的一个缺点在于当一个消息的完成耗时过长，网络应用无法处理用户的交互如点击或者滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个比较好的解决方案是使消息处理变短且如果可能的话，将一个消息拆分成几个消息。</p>
<p><strong>添加消息</strong></p>
<p>在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。</p>
<p>调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。</p>
<p><strong>零延迟</strong></p>
<p>零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。在下面的例子中，”this is just a message” 将会在回调 (callback) 获得处理之前输出到控制台，这是因为延迟是要求运行时 (runtime) 处理请求所需的最小时间，但不是有所保证的时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'this is the start'</span>);</div><div class="line"></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'this is a msg from call back'</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'this is just a message'</span>);</div><div class="line"></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'this is a msg from call back1'</span>);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'this is the  end'</span>);</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// "this is the start"</span></div><div class="line"><span class="comment">// "this is just a message"</span></div><div class="line"><span class="comment">// "this is the end"</span></div><div class="line"><span class="comment">// "this is a msg from call back"</span></div><div class="line"><span class="comment">// "this is a msg from call back1"</span></div></pre></td></tr></table></figure>
<p><strong>多个运行时互相通信</strong></p>
<p>一个 web worker 或者一个跨域的 iframe 都有它们自己的栈，堆和消息队列。两个不同的运行时只有通过 postMessage 方法进行通信。这个方法会给另一个运行时添加一个消息如果后者监听了 message 事件。</p>
<h4 id="绝不阻塞"><a href="#绝不阻塞" class="headerlink" title="绝不阻塞"></a>绝不阻塞</h4><p>一个很有趣的事件循环 (event loop) 模型特性在于，Javascript 跟许多其它语言不同，它永不阻塞。通常由事件或者回调函数进行 I/O (input/output)处理 。所以当一个应用正等待 IndexedDB 的查询的返回或者一个 XHR 的请求返回时，它仍然可以处理其它事情例如用户输入。</p>
<p>例外是存在的，如 alert 或者同步 XHR，但应该尽量避免使用它们。注意，例外的例外也是存在的（但通常是实现错误而非其它原因）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件！事件！事件！&quot;&gt;&lt;a href=&quot;#事件！事件！事件！&quot; class=&quot;headerlink&quot; title=&quot;事件！事件！事件！&quot;&gt;&lt;/a&gt;事件！事件！事件！&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://developer.mo
    
    </summary>
    
    
      <category term="javascript" scheme="http://yiniau.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>各种奇怪的不奇怪的命令</title>
    <link href="http://yiniau.com/2017/06/26/%E5%90%84%E7%A7%8D%E5%A5%87%E6%80%AA%E7%9A%84%E4%B8%8D%E5%A5%87%E6%80%AA%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://yiniau.com/2017/06/26/各种奇怪的不奇怪的命令/</id>
    <published>2017-06-26T13:24:11.000Z</published>
    <updated>2017-06-26T13:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令笔记"><a href="#命令笔记" class="headerlink" title="命令笔记"></a>命令笔记</h1><h3 id="zipinfo"><a href="#zipinfo" class="headerlink" title="zipinfo"></a>zipinfo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zipinfo [-12hlmMstTvz][压缩文件][文件...][-x &lt;范本样式&gt;]</div></pre></td></tr></table></figure>
<p>参数：<br>-1 只列出文件名称。<br>-2 此参数的效果和指定”-1”参数类似，但可搭配”-h”,”-t”和”-z”参数使用。<br>-h 只列出压缩文件的文件名称。<br>-l 此参数的效果和指定”-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率。<br>-m 此参数的效果和指定”-s”参数类似，但多会列出每个文件的压缩率。<br>-M 若信息内容超过一个画面，则采用类似more指令的方式列出信息。<br>-s 用类似执行”ls -l”指令的效果列出压缩文件内容。<br>-t 只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率。<br>-T 将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出。<br>-v 详细显示压缩文件内每一个文件的信息。<br>-x&lt;范本样式&gt; 不列出符合条件的文件的信息。<br>-z 如果压缩文件内含有注释，就将注释显示出来。</p>
<blockquote>
<p>我在mac上解压一些不可描述的文件的时候需要拿到压缩文件中的注释信息，因为是.zip文件，直接<code>zipinfo -z xxx</code>就行了</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;命令笔记&quot;&gt;&lt;a href=&quot;#命令笔记&quot; class=&quot;headerlink&quot; title=&quot;命令笔记&quot;&gt;&lt;/a&gt;命令笔记&lt;/h1&gt;&lt;h3 id=&quot;zipinfo&quot;&gt;&lt;a href=&quot;#zipinfo&quot; class=&quot;headerlink&quot; title=&quot;zip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[翻译]E10S-Multi, WebExtension APIs, CSS clip-path.md</title>
    <link href="http://yiniau.com/2017/06/20/E10S-Multi-WebExtension-APIs-CSS-clip-path-md/"/>
    <id>http://yiniau.com/2017/06/20/E10S-Multi-WebExtension-APIs-CSS-clip-path-md/</id>
    <published>2017-06-20T10:28:33.000Z</published>
    <updated>2017-06-22T13:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻译-E10S-Multi-WebExtension-APIS-CSS-clip-path"><a href="#翻译-E10S-Multi-WebExtension-APIS-CSS-clip-path" class="headerlink" title="[翻译]E10S-Multi, WebExtension APIS, CSS clip-path"></a>[翻译]E10S-Multi, WebExtension APIS, CSS clip-path</h1><p>翻译自 <a href="https://hacks.mozilla.org/2017/06/firefox-54-e10s-webextension-apis-css-clip-path/?utm_source=dev-newsletter&amp;utm_medium=email&amp;utm_campaign=jun15-2017" target="_blank" rel="external">mozilla  hacks</a></p>
<hr>
<h3 id="“E10S-Multi-”-A-new-multi-process-model-for-Firefox"><a href="#“E10S-Multi-”-A-new-multi-process-model-for-Firefox" class="headerlink" title="“E10S-Multi:” A new multi-process model for Firefox"></a>“E10S-Multi:” A new multi-process model for Firefox</h3><p>今天的发布完成了Firefox向多进程浏览器的转变，除了UI进程之外，还运行了许多同步的内容进程，在Windows上有一个特殊的GPU进程。这样的设计会更容易激发现代处理器上可用的核心，并且使浏览器沙箱更加安全。它还提升了稳定性，一个页面进程的崩溃不回影响全部的tabs或者浏览器的其余部分。</p>
<blockquote>
<p>Today’s release completes Firefox’s transformation into a fully multi-process browser, running many simultaneous content processes in addition to a UI process and, on Windows, a special GPU process. This design makes it easier to utilize all of the cores available on modern processors and, in the future, to securely sandbox web content. It also improves stability, ensuring that a single content process crashing won’t take out all of your other tabs, nor the rest of the browser.</p>
</blockquote>
<p><img src="https://hacks.mozilla.org/files/2017/06/e10s-multi.png" alt="multi-process"></p>
<p>初始的多进程Firefox（代号为 “Electrolysis” 简写为 “e10s”）首次亮相于Firefox 48。第一版将Firefox的UI移入了一个独立的进程，这样的话浏览器界面即使是在页面加载的时候也很快。Firefox 54通过并行运行许多内容进程来进一步实现这一点：每个进程都具有由主机操作系统管理的自己的RAM和CPU资源。</p>
<blockquote>
<p>An initial version of multi-process Firefox (codenamed “Electrolysis”, or “e10s” for short) debuted with Firefox 48 last August. This first version moved Firefox’s UI into its own process so that the browser interface remains snappy even under load. Firefox 54 takes this further by running many content processes in parallel: each one with its own RAM and CPU resources managed by the host operating system.</p>
</blockquote>
<p>无论优化程度如何，额外的进程确实带来了较少的内存开销，但是我们已经尝试将其减少到最低限度。即使有了这些优化，我们还想做更多的工作，以确保Firefox对您的RAM友好。这就是为什么不是每个选项卡产生一个新的进程，Firefox设置了一个上限：默认为四个，但可由用户配置（dom.ipc.processCount in about：config）。这在让Firefox在使用更强的多核CPUs的同时保证了你的控制权</p>
<blockquote>
<p>Additional processes do come with a small degree of memory overhead, no matter how well optimized, but we’ve worked wonders to reduce this to the bare minimum. Even with those optimizations, we wanted to do more to ensure that Firefox is respectful of your RAM. That’s why, instead of spawning a new process with every tab, Firefox sets an upper limit: four by default, but configurable by users (dom.ipc.processCount in about:config). This keeps you in control, while still letting Firefox take full advantage of multi-core CPUs.</p>
</blockquote>
<p>了解更多有关Firefox的多进程体系结构，查看<a href="https://medium.com/mozilla-tech/the-search-for-the-goldilocks-browser-and-why-firefox-may-be-just-right-for-you-1f520506aa35" target="_blank" rel="external">Medium post about the search for the “Goldilocks” browser.</a></p>
<blockquote>
<p>To learn more about Firefox’s multi-process architecture, check out this Medium post about the search for the “Goldilocks” browser.</p>
</blockquote>
<h3 id="new-WebExtension-APIs"><a href="#new-WebExtension-APIs" class="headerlink" title="new WebExtension APIs"></a>new WebExtension APIs</h3><p>Firefox继续快速实施新的WebExtension API。这些API旨在跨浏览器工作，并且将是Firefox 57今年11月推出的唯一可用于附加组件的API。</p>
<blockquote>
<p>Firefox continues its rapid implementation of new WebExtension APIs. These APIs are designed to work cross-browser, and will be the only APIs available to add-ons when Firefox 57 launches this November.</p>
</blockquote>
<p>最值得注意的是，现在可以使用WebExtensions创建自定义DevTools面板。例如，下面的屏幕截图显示了在Firefox中运行的Vue.js DevTools的Chrome版本，无需任何修改。这大大降低了devtools附加组件作者的维护负担，确保无论您喜欢哪种框架，其工具都可以在Firefox中运行。  </p>
<p><img src="https://hacks.mozilla.org/files/2017/06/Screen-Shot-2017-06-12-at-19.14.30.png" alt="vue.js devtools"></p>
<blockquote>
<p>Most notably, it’s now possible to create custom DevTools panels using WebExtensions. For example, the screenshot below shows the Chrome version of the Vue.js DevTools running in Firefox without any modifications. This dramatically reduces the maintenance burden for authors of devtools add-ons, ensuring that no matter which framework you prefer, its tools will work in Firefox.</p>
</blockquote>
<p>另外：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json/sidebar_action" target="_blank" rel="external">侧边栏</a>可以通过sidebar_action清单属性创建。与其他API一起，侧边栏可用于实现<a href="https://addons.mozilla.org/en-US/firefox/addon/sidebar-tabs-webextension/" target="_blank" rel="external">垂直</a>或<a href="https://addons.mozilla.org/firefox/addon/tree-tabs/" target="_blank" rel="external">树形</a>样式选项卡等。</li>
<li>WebExtensions 现在能够<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json/chrome_url_overrides" target="_blank" rel="external">替换或自定义标签页</a>(<a href="https://github.com/mdn/webextensions-examples/tree/master/top-sites" target="_blank" rel="external">exmaple</a>)</li>
<li>WebExtensions也可以注册对<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json/protocol_handlers" target="_blank" rel="external">自定义协议</a>的支持。例如，加载项可以将<code>irc：//</code>链接重定向到IRCCloud。</li>
</ul>
<p>请阅读附加组件博客上全套<a href="https://blog.mozilla.org/addons/2017/03/13/webextensions-firefox-54/" target="_blank" rel="external">新增和更改的API</a>，或查看MDN上的完整WebExtensions文档。</p>
<blockquote>
<p>Additionally:</p>
<ul>
<li>Sidebars can be created via a sidebar_action manifest property. Together with other APIs, sidebars can be used to implement vertical or tree-style tabs, among other things.</li>
<li>WebExtensions can now replace or customize the New Tab page. (Example).</li>
<li>WebExtensions can also register support for custom protocols. For example, an add-on could redirect irc:// links to IRCCloud.</li>
</ul>
<p>Read about the full set of new and changed APIs on the Add-ons Blog, or check out the complete WebExtensions documentation on MDN.</p>
</blockquote>
<h1 id="CSS-shapes-in-clip-path"><a href="#CSS-shapes-in-clip-path" class="headerlink" title="CSS shapes in clip-path"></a>CSS shapes in clip-path</h1><p>CSS clip-path(剪辑路径)属性允许作者定义元素的哪些部分是可见的。以前，Firefox只支持定义为SVG文件的剪切路径。使用Firefox 54，作者还可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape" target="_blank" rel="external">CSS shape functions</a> (形状函数)进行圆，椭圆，矩形或任意多边形（<a href="https://codepen.io/ladybenko/pen/oWJBwW" target="_blank" rel="external">Demo</a>）。</p>
<blockquote>
<p>The CSS clip-path property allows authors to define which parts of an element are visible. Previously, Firefox only supported clipping paths defined as SVG files. With Firefox 54, authors can also use CSS shape functions for circles, ellipses, rectangles or arbitrary polygons (Demo).</p>
</blockquote>
<p>想许多CSS值一样，剪切形状可以动画化。有一些规则控制<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape#Interpolation_of_basic_shapes" target="_blank" rel="external">如何执行值之间的插值</a>，长话短说，当你在相同的形状或者具有相同数量顶点的多边形内进行插值，则一切都好。</p>
<p><strong>exmaple</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://hacks.mozilla.org/files/2017/06/firefox-logo.png"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.circle</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">2s</span> infinite alternate circle;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">keyframes</span> circle &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123;</div><div class="line">    <span class="attribute">-webkit-clip-path</span>: <span class="built_in">circle</span>(0%);</div><div class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(0%);</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">to</span> &#123;</div><div class="line">    <span class="attribute">-webkit-clip-path</span>: <span class="built_in">circle</span>(120px);</div><div class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(120px);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">align-items</span>: center;</div><div class="line">  <span class="attribute">justify-content</span>: center;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">90vh</span>;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &gt; * &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://codepen.io/ladybenko/pen/NjoKVy" target="_blank" rel="external">剪切动画的demo on codepen</a></p>
<blockquote>
<p>Like many CSS values, clipping shapes can be animated. There are some rules that control how the interpolation between values is performed, but long story short: as long as you are interpolating between the same shapes, or polygons with the same number of vertices, you should be fine. Here’s how to animate a circular clipping:</p>
</blockquote>
<p>您还可以根据用户输入动态更改裁剪，如本示例中具有鼠标控制的<a href="https://codepen.io/ladybenko/pen/qmvKrM" target="_blank" rel="external">“潜望镜”效果的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.frame'</span>);</div><div class="line"><span class="keyword">const</span> RADIUS = <span class="number">80</span>;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> x = event.clientX;</div><div class="line">  <span class="keyword">let</span> y = event.clientY;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> circle = <span class="string">`circle(<span class="subst">$&#123;RADIUS&#125;</span>px at <span class="subst">$&#123;x&#125;</span>px <span class="subst">$&#123;y&#125;</span>px)`</span>;</div><div class="line">  container.style[<span class="string">'-webkit-clip-path'</span>] = circle;</div><div class="line">  container.style[<span class="string">'clip-path'</span>] = circle;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"frame"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"message"</span>&gt;</span>Move the mouse around…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.frame</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(https://hacks.mozilla.org/files/2017/06/benko-game.png);</div><div class="line">  <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">  <span class="attribute">background-position</span>: left center;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line"></div><div class="line">  <span class="attribute">-webkit-clip-path</span>: <span class="built_in">circle</span>(80px);</div><div class="line">  <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(80px);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.message</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">font-family</span>: monospace;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#0006</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>You can also dynamically change clipping according user input, like in this example that features a “periscope” effect controlled by the mouse:</p>
</blockquote>
<p>了解更多，查看我们<a href="https://hacks.mozilla.org/2017/06/css-shapes-clipping-and-masking/" target="_blank" rel="external">上周的 clip-path 文章</a>。</p>
<blockquote>
<p>To learn more, check our article on clip-path from last week.</p>
</blockquote>
<h1 id="Project-Dawn"><a href="#Project-Dawn" class="headerlink" title="Project Dawn"></a>Project Dawn</h1><p>最后，Firefox 54的发布标志着<a href="http://release.mozilla.org/firefox/release/2017/05/30/Dawn-update.html" target="_blank" rel="external">项目“Dawn”</a>转换的完成，消除了Firefox的预测版发布渠道，代号为“Aurora”。Firefox发行版现在每六个星期直接从Nightly转为Beta版。基于Aurora的Firefox Developer Edition现在基于Beta。</p>
<blockquote>
<p>Lastly, the release of Firefox 54 marks the completion of the Project Dawn transition, eliminating Firefox’s pre-beta release channel, codenamed “Aurora.” Firefox releases now move directly from Nightly into Beta every six weeks. Firefox Developer Edition, which was based on Aurora, is now based on Beta.</p>
</blockquote>
<p>对于早期采用者，我们还在Google Play上提供了适用于Android的<a href="https://play.google.com/store/apps/details?id=org.mozilla.fennec_aurora" target="_blank" rel="external">Firefox Nightly</a>。</p>
<blockquote>
<p>For early adopters, we’ve also made Firefox Nightly for Android available on Google Play.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻译-E10S-Multi-WebExtension-APIS-CSS-clip-path&quot;&gt;&lt;a href=&quot;#翻译-E10S-Multi-WebExtension-APIS-CSS-clip-path&quot; class=&quot;headerlink&quot; title=&quot;[翻
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker笔记_2_Dockerfile</title>
    <link href="http://yiniau.com/2017/05/26/docker%E7%AC%94%E8%AE%B0-2-Dockerfile/"/>
    <id>http://yiniau.com/2017/05/26/docker笔记-2-Dockerfile/</id>
    <published>2017-05-26T05:44:26.000Z</published>
    <updated>2017-05-31T14:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>image 采用Union-FS分层储存，通过 <code>docker commit</code> 可以保存容器的储存层为一个新的镜像，也就是将运行时储存层持久化为 image 中的一层结构</p>
<p>但是直接使用 commit 会出现诸多问题，使用 <code>docker diff &lt;container name|ID|shareID&gt;</code> 可以观察到commit之前之后的变动，在一个命令被执行后会有大量无关内容被添加，特别是一些安装软件的命令。直接使用 commit 很容易造成 image 臃肿，使用 commit 生成的 image 也被称为 <strong>黑箱镜像</strong>（生成过程不透明）。</p>
<p>docker 官方最佳实践的做法为使用 <strong>Dockerfile</strong> 定制image</p>
<h4 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h4><ul>
<li>FROM 制定基础镜像</li>
<li>RUN  执行命令</li>
<li>COPY 复制文件</li>
<li>ADD  高级的复制文件指令</li>
<li>CMD  容器启动命令</li>
<li>ENTRYPOINT 入口文件</li>
<li>ENV  设置环境变量</li>
<li>ARG  构建参数</li>
<li>VOLUME 定义匿名卷（数据卷）</li>
<li>EXPOSE 暴露接口</li>
<li>WORKDIR 制定工作目录</li>
<li>USER    制定当前用户</li>
<li>HEALTHCHECK 健康检查</li>
<li>ONBUILD 为他人做嫁衣</li>
</ul>
<p>在 Dockerfile 中每出现一个 <code>RUN</code> 就会多构建一层镜像</p>
<h4 id="使用-Dockerfile-定义-container"><a href="#使用-Dockerfile-定义-container" class="headerlink" title="使用 Dockerfile 定义 container"></a>使用 Dockerfile 定义 container</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure>
<p>上面的 Dockerfile 会新建7层镜像，多出了许多没有意义的，运行时不需要的东西。</p>
<p>这些RUN命令的目的是编译安装<code>redis</code>可执行文件，只需要用1层代替即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></div></pre></td></tr></table></figure>
<p>使用 <code>&amp;&amp;</code> 将所需命令串街起来，简化为1层。<br>Dockerfile 支持使用 <code>\</code> 对命令进行换行，格式化命令代码。</p>
<p>下面是一个大体的例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use an official Python runtime as a base image</span></div><div class="line"><span class="comment"># 使用一个官方的 Python runtime 作为基础镜像</span></div><div class="line">FROM python:2.7-slim</div><div class="line"></div><div class="line"><span class="comment"># Set the working directory to /app</span></div><div class="line"><span class="comment"># 将工作目录设置到 /app</span></div><div class="line">WORKDIR /app</div><div class="line"></div><div class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></div><div class="line"><span class="comment"># 复制当前目录下的内容到容器文件系统的 /app 下</span></div><div class="line">ADD . /app</div><div class="line"></div><div class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></div><div class="line"><span class="comment"># 安装任何需要的在 requirements.txt 中说明的 packages</span></div><div class="line">RUN pip install -r requirements.txt</div><div class="line"></div><div class="line"><span class="comment"># Make port 80 available to the world outside this container</span></div><div class="line"><span class="comment"># 将 80 端口暴露给 contanier 外部</span></div><div class="line">EXPOSE 80</div><div class="line"></div><div class="line"><span class="comment"># Define environment variable</span></div><div class="line"><span class="comment"># 定义环境变量</span></div><div class="line">ENV NAME World</div><div class="line"></div><div class="line"><span class="comment"># Run app.py when the container launches</span></div><div class="line"><span class="comment"># 当 container 启动是运行 app.py</span></div><div class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</div></pre></td></tr></table></figure>
<p>这个 <code>Dockerfile</code> 文件还包含了几个我们还没有创建的文件，即 <code>app.py</code> 和 <code>requirements.txt</code>。</p>
<p>接下来就是完成这两个文件了</p>
<h4 id="应用本身"><a href="#应用本身" class="headerlink" title="应用本身"></a>应用本身</h4><p>抓取将这两个文件并将他们放在 dockerfile 所在的文件夹下。</p>
<p>这就已经完成了一个应用，十分简单。</p>
<blockquote>
<p>当前面的 <code>Dockerfile</code> 被 build 成 image 时，<code>app.py</code> 和 <code>requirements.txt</code> 会被 <code>ADD</code> 命令添加，而 <code>app.py</code> 的输出则能通过 <code>EXPOSE</code> 命令使外部能够通过 HTTP 访问。</p>
</blockquote>
<p><strong>requriements.txt</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Flask</div><div class="line">Redis</div></pre></td></tr></table></figure>
<p><strong>app.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="comment"># Connect to Redis</span></div><div class="line">redis = Redis(host=<span class="string">"redis"</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        visits = redis.incr(<span class="string">"counter"</span>)</div><div class="line">    <span class="keyword">except</span> RedisError:</div><div class="line">        visits = <span class="string">"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"</span></div><div class="line"></div><div class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span> \</div><div class="line">           <span class="string">"&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;"</span></div><div class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname(), visits=visits)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</div></pre></td></tr></table></figure>
<p>现在将看到 <code>pip install -r requirements.txt</code> 会为Python安装Flask和Redis库，并且app将会打印出环境变量 <code>NAME</code>，并且输出<code>socket.gethostname()</code>的结果。<br>最终，由于 Redis 没有在运行(因为只安装了Python库，并不是Redis自身)，我们能够预计尝试使用它的时候会失败并产生错误信息。</p>
<h4 id="Build-the-App"><a href="#Build-the-App" class="headerlink" title="Build the App"></a>Build the App</h4><p>构建开始前在系统中并不需要Python或者其他任何在requirements.txt文件中求的东西，也不会将用于构建image的库安装到主机系统上。</p>
<p>运行编译命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyhello .</div></pre></td></tr></table></figure>
<p>查看images</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker images</div><div class="line"></div><div class="line">REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">friendlyhello                               latest              d5a69ab6bd43        24 hours ago        195 MB</div></pre></td></tr></table></figure>
<p>运行后会出现一个个通知，指出Python正在 <a href="http://0.0.0.0:80" target="_blank" rel="external">http://0.0.0.0:80</a> 为你的应用程序提供服务。 但是，该消息来自容器内部，并不知道你通过 <code>EXPOSE</code> 将该容器的80端口暴露并在启动命令中remapping80到4000，正确的URL为 <strong>http：// localhost：4000</strong>。 在浏览器中访问，你会看到“Hello World”文本，容器ID和Redis错误信息。</p>
<h4 id="run-应用"><a href="#run-应用" class="headerlink" title="run 应用"></a>run 应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 4000:80 friendlyhello</div></pre></td></tr></table></figure>
<p>将会在运行 friendlyhello ，并将在 Dockerfile 中使用 <code>EXPOSE</code> 暴露的 80 端口并重映射到 4000。</p>
<p>运行之后将提示信息，提示在 <code>http://0.0.0.0:80</code> 中运行服务，但这是在 container 中的地址，主机访问的正确地址为 <code>http://localhost:4000</code>。</p>
<p><strong>后台运行 | 分离模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 4000:80 friendlyhello</div></pre></td></tr></table></figure>
<p>运行后会得到一条巨长的 container ID,可以使用 <code>docker ps</code> 查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker ps</div><div class="line"></div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</div><div class="line">ed4cab2deb90        friendlyhello       <span class="string">"python app.py"</span>     24 hours ago        Up About a minute   0.0.0.0:4000-&gt;80/tcp   sad_curie</div></pre></td></tr></table></figure>
<p>使用 <code>docker stop ed4cab2deb90</code> 即可停止运行。</p>
<h4 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker build -t friendlyname .  <span class="comment"># Create image using this directory's Dockerfile</span></div><div class="line">docker run -p 4000:80 friendlyname  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></div><div class="line">docker run -d -p 4000:80 friendlyname         <span class="comment"># Same thing, but in detached mode</span></div><div class="line">docker ps                                 <span class="comment"># See a list of all running containers</span></div><div class="line">docker stop &lt;<span class="built_in">hash</span>&gt;                     <span class="comment"># Gracefully stop the specified container</span></div><div class="line">docker ps -a           <span class="comment"># See a list of all containers, even the ones not running</span></div><div class="line">docker <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;                   <span class="comment"># Force shutdown of the specified container</span></div><div class="line">docker rm &lt;<span class="built_in">hash</span>&gt;              <span class="comment"># Remove the specified container from this machine</span></div><div class="line">docker rm $(docker ps -a -q)           <span class="comment"># Remove all containers from this machine</span></div><div class="line">docker images -a                               <span class="comment"># Show all images on this machine</span></div><div class="line">docker rmi &lt;imagename&gt;            <span class="comment"># Remove the specified image from this machine</span></div><div class="line">docker rmi $(docker images -q)             <span class="comment"># Remove all images from this machine</span></div><div class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></div><div class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></div><div class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></div><div class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h1&gt;&lt;p&gt;image 采用Union-FS分层储存，通过 &lt;code&gt;docker c
    
    </summary>
    
      <category term="docker" scheme="http://yiniau.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yiniau.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记_1</title>
    <link href="http://yiniau.com/2017/05/25/docker%E7%AC%94%E8%AE%B0_1/"/>
    <id>http://yiniau.com/2017/05/25/docker笔记_1/</id>
    <published>2017-05-25T10:42:23.000Z</published>
    <updated>2017-06-06T00:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h4><p><a href="https://docs.docker.com/get-started/#container-diagram" target="_blank" rel="external">官方文档</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="external">docker从入门到实践</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我是用的是mac，所以直接使用<code>brew install docker</code>就能顺利安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker -v</div><div class="line">$ Docker version 17.03.1-ce, build c6d412e</div></pre></td></tr></table></figure>
<h4 id="先决知识"><a href="#先决知识" class="headerlink" title="先决知识"></a>先决知识</h4><ul>
<li>IP Addresses and Ports        || IP地址和端口</li>
<li>Virtual Machines              || 虚拟机</li>
<li>Editing configuration files   || 编辑配置文件</li>
<li>Basic familiarity with the ideas of code dependencies and building || 基本熟悉代码依赖和构建的思想</li>
<li>Machine resource usage terms, like CPU percentages, RAM use in bytes, etc. || 机器资源使用条款，如CPU百分比，RAM使用字节数等</li>
</ul>
<h4 id="containers-and-images-lt-容器-gt-和-lt-镜像-gt"><a href="#containers-and-images-lt-容器-gt-和-lt-镜像-gt" class="headerlink" title="containers and images || &lt;容器&gt;和&lt;镜像&gt;"></a>containers and images || &lt;容器&gt;和&lt;镜像&gt;</h4><p><strong>image</strong> 镜像是一个轻量级的、独立的、可执行的 package ，包含了所有运行一个程序需要的一切，包含 code,a runtime,libraries,environment variables,and config files。</p>
<blockquote>
<p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。</p>
</blockquote>
<p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="external">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非像是一个ISO那样的打包文件，而是一个虚拟的概念。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<blockquote>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
</blockquote>
<p><strong>container</strong> 容器是<strong>一个</strong>运行时镜像的<strong>实例</strong> - what the images becomes in memory when actully executed.<br>默认情况下，它与主机环境完全隔离，只能访问主机文件和端口（如果配置为这样做）。(端口和文件的访问都需要经过配置)<br>容器运行在主机的内核上，可以说容器的实质是进程，但是与普通进程不同的是容器拥有独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="external">命名空间</a>,因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<br>容器与镜像一样也使用了分层储存。<br>每一个容器运行时都是以镜像为基础层，在其上创建一个为容器运行时读写准备的储存层，可以称为<strong>容器储存层</strong><br>当容消亡时容器储存层同样消失，任何保存在容器储存层中的数据都会丢失。<br>按照 <a href="">Docker 最佳实践</a>的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<h4 id="Containers-与传统虚拟机的比较"><a href="#Containers-与传统虚拟机的比较" class="headerlink" title="Containers 与传统虚拟机的比较"></a>Containers 与传统虚拟机的比较</h4><p><strong>Virtual Machine diagram</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">          |=========|</div><div class="line">          |   VM    |</div><div class="line">|---------|---------|---------|</div><div class="line">|  App A  |  App B  |  App C  |</div><div class="line">|---------|---------|---------|</div><div class="line">|Bins/Libs|Bins/Libs|Bins/Libs|</div><div class="line">|---------|---------|---------|</div><div class="line">| GuestOS | GuestOS | GuestOS |</div><div class="line">|         |=========|         |</div><div class="line">|=============================|</div><div class="line">|          Hypervisor         |</div><div class="line">|-----------------------------|</div><div class="line">|          Host   OS          |</div><div class="line">|-----------------------------|</div><div class="line">|       Infrastructure        |</div><div class="line">|-----------------------------|</div></pre></td></tr></table></figure>
<p><strong>Container diagram</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">        |=============|</div><div class="line">        |  CONTAINER  |</div><div class="line">        |_           _|</div><div class="line">|---------|---------|---------|</div><div class="line">|  App A  |  App B  |  App C  |</div><div class="line">|---------|---------|---------|</div><div class="line">|Bins/Libs|Bins/Libs|Bins/Libs|</div><div class="line">|         |=========|         |</div><div class="line">|=============================|</div><div class="line">|        Docker Engine        |</div><div class="line">|-----------------------------|</div><div class="line">|          Host  OS           |</div><div class="line">|-----------------------------|</div><div class="line">|       Infrastructure        |</div><div class="line">|-----------------------------|</div></pre></td></tr></table></figure>
<p>传统虚拟机技术会虚拟一整套硬件，并在其上运行一个完整的操作系统，之后再运行应用程序<br>而容器内的应用直接运行于宿主机的内核上，容器没有自己的内核,多个容器可以共享一个内核。<br>容器也不进行硬件模拟，因此容器要比虚拟机<strong>轻快</strong>不少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;主要参考资料&quot;&gt;&lt;a href=&quot;#主要参考资料&quot; class=&quot;headerlink&quot; title=&quot;主要参考资料&quot;&gt;&lt;/a&gt;主要参考资料&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/#containe
    
    </summary>
    
    
      <category term="docker" scheme="http://yiniau.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yiniau.com/2017/05/23/hello-world/"/>
    <id>http://yiniau.com/2017/05/23/hello-world/</id>
    <published>2017-05-23T15:56:06.000Z</published>
    <updated>2017-05-23T15:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
